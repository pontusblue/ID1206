\documentclass[a4paper, 12pt]{article}
\usepackage{graphicx}
\def\code#1{\texttt{#1}}
\begin{document}

\title{\vspace{4.0cm}Operating Systems - Seminar 3 Report}
\author{Pontus Asp}
\date{\today}
\maketitle
\thispagestyle{empty}
\pagenumbering{roman}
\newpage

\tableofcontents
\newpage

\clearpage
\pagenumbering{arabic}

% Write here ->
\section{Introduction}
In this article I will write about my progress on writing a thread library (from skeleton code) for seminar 3 in the operating systems course at KTH. Before I started coding I learned from last time that getting the debugger up and running is a good starting point, so that's what I did. After I got the debugger working I started reading through the pdf to have a better overview of the structure of the thread. I felt like multi-threading is hard enough by itself so I did not want to get stuck just because I was too lazy to be a little bit better prepared. However maybe I should not say this since I did not even finish the multi-threading assignment we had earlier in the course.

\section{Let's start coding - Managing contexts}
Now that I felt done preparing I started reading the pdf from the start again and started implementing the skeleton code. This section will be dedicated to the functions \code{green\_create/3}, \code{green\_yield/0} and \code{green\_join/2}.
\newline Additionally, it took me a little while to understand what the \code{context} word ment. But after a while I realized that the context should literally be like the context of each thread - i.e. something that keeps track of the stack, variables and where a thread is currently executing. So to sum it up, a context is essenitally an image of the state of a thread and this is how we can switch between the different threads - by switching out which context is currently active.

\subsection{Creating a thread structure}
The create function (\code{green\_create/3}) is responsible for initializing all the values needed for a thread, for instance creating a seperate context for the new thread and initializing that context to start in the desired function we want to run the thread in.
If I would be creating this function from the ground up I would probably have some issues trying to figure out everything we would need to save for a thead - and well I did not know about contexts before so that would probably take me a while to solve.

\subsection{Yield, thread!}
The yield function (\code{green\_yield/0}) is a the function that should be called from a thread when it is time for the thread to rest and put another one in charge. From the start we implemented this in a way so that the threads would call it manually to release control. But since this could lead to other threads never getting control if the current thread would get stuck in an infinite loop or, never give up control, we later changed this to be called via a timer interrupt.
Creating the yield function was very easy compared to the other context managing functions - but it was also the shortest with the least amount of logic so this is not very surprising after having finished it.

\subsection{The join operation}
The join operation (\code{green\_join/2}), is a function that manages a context that needs to wait for a result from another thread (when it is done executing) or simply to wait for it to finish. In addition to this the join operation also clears up the resources used by the thread that was given to join when it finally joins after being done with its execution. This function was the one I had most issues programming because I was unsure of who would be ``joining'' who and which thread would be the one to execute after checking if the thread we wanted to join was a zombie or not. Now after understanding it fully, I would say it is pretty simple - but it took a while to get there so I would understand if people had issues understanding exactly what is going on here.

\section{Writing a little test}
So now that we have written quite a bit of code - it would be very nice with a test. Fortunately Johan did put a test at this point in the assignment - and it was a good thing he did. Writing the test was easy, especially since we were given the complete code. However what followed was harder, segmentation faults. But luckily enough, as I said in the introduction,  I had a debugger set up from the start this time. I found that the first segmentation fault was in my \code{green\_join/2} function. It took me a long time to figure out exactly what the issue was, but eventually I found out that there was nothing wrong directly with the code in the seminar (yet), it was the helper function I created for queueing and popping threads from the ready queue. I built it so that I had a reference to the head and the tail, and when popping the last element from the head I forgot to clear the reference at the tail, which made the head set to \code{NULL}, while the tail still saying we had one item in the queue. When finally finding this issue and I simply cleared the tail it worked, kind of. It would still run into issues occasionally but I decided to continue with the rest of the implementation anyways since I could not find any more bugs. (I did find it in later tests though so I will bring it up then).

\section{Suspending threads implementation}
So far we have not implemented any kind of locks for our threads - this might seem like a really bad idea, and normally it is, at least in a fully developed threading library with locks in place. But so far this has been fine since we know what we have been doing. In our test we run the work on each thread and let the thread decide when to pass the active context to the next thread in the queue using \code{green\_yield/0}. So since we decided when to switch thread this has not been a problem, but as mentioned earlier this would not be a good idea since threads could potentially run into issues in larger programs and freeze the whole system if it never gives back control. So as a start to fix this issue we will start with making this a bit better by suspending on conditions.

\subsection{Initializing a condition}
The first step in creating a condition would be initializing it (\code{green\_cond\_init/1}). The structure simply contains a single value, which is the queue that decides which thread is currently in control. Implementing this was not hard, the only thing I had to think about was if it really was as easy as it seemed, and it was.

\subsection{Wait for your turn}
At this point we want to create some function (\code{green\_cond\_wait/1}) that can make a thread wait if it does not have anything to do during its allocated time, instead of wasting precious clock cycles. So to solve this we have the wait function, the first version of this function was pretty straight forward - find the next thread to run and the running thread puts itself on the condition queue to be ran again sometime later.

\subsection{Sound the signal!}
Making all the threads sleep or simply just wait would make my life easy - deadlocks on purpose. But in reality we do not want any deadlocks since nothing would be working, so to not make all the threads go to sleep we need to wake up the next thread in the queue and switch to their context. This is what the function \code{green\_cond\_signal/1} is made for. When this function is called, the first thread in the conditional queue will be moved to the ready queue. By doing this that thread will be ran as soon as it gets its turn.

\subsection{Updating the test}
After adding this new functionality we of course want to use it! So to be able to use it we will have to update the old test function and add a few lines. The essential change is that we have a flag that decides which thread will enter an if block, if they do, they update the flag and update their loop count. After that they use \code{green\_cond\_signal/1} to wake up one of the threads that did not go in to the if block. The threads that did not go in to the if block instead hit the \code{green\_cond\_wait/1} function and is sitting and waiting for a signal. We still have one problem though - the programs themselves still decide when it is time for a thread to give back control, so in the next section we will look into that.

\section{Adding a timer interrupt}
To solve the problem with threads possibly being given control that they never give back we will introduce timer interrupts that automatically calls the \code{green\_yield/0} function for them.
All we basically needed to do was inizialize the timer in our \code{init/0} function and give it the function to call when the timer ran out. This was not enough however - we ran into strange behaviour since we now did not have any control of when a thread would give back the control. To fix this we had to block the timer from interrupting during volatile operations such as when we are changing the state of the green threads. There is one problem with this though and it is if we would have volatile operations that the threads will work with that is in their workload - what the programmers write when using this library. To give the programmers some way to write code that works in paralell with shared resources between the threads we will introduce mutexes.

\section{A Mutex for the programmers}
Who knew that a thread library maybe should include a way for the developers using it to write code that works with shared resources, oh well but here we are doing just that. This was of course a joke, if not for the mutexes I would probable have had my OS die multiple times just trying to write this file. Since this report is getting a bit long I will try to write about this in a bit more space efficient way. When implementing the mutex functionality we made 3 functions - the good 'ol init function that only initializes our mutex structure, a locking function, which is made for threads to be able to "claim" the spotlight for a resource - making all the other threads having to wait if they want to claim the save mutex. Then we also of course made the opposite one - the unlock function, which just gives control to the next thread in line, or just unlocks the mutex if no one is waiting for it.

\section{A final little update}
The test is once again outdated, now with the power of mutexes we want to lock down access of the \code{flag} variable so that only one thread can read and write to it at a time, this saves us from the small chance that two threads would enter the if statement at the same time, or two threads trying to increment the flag at the same time.

\section{Benchmarks}
There are none.


% Write here <--

\end{document}